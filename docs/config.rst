Configuring CumulusCI
=====================
CumulusCI is configured using files called cumulusci.yml which define the automation that is available for a project.
By default, a project inherits a default configuration from the cumulusci.yml file in CumulusCI itself, which we call the "universal config".
A project can tailor CumulusCI by overriding specific parts of the configuration in the cumulusci.yml file within the project directory, which we call the "project config."



``cumulusci.yml`` Structure
---------------------------
There are six top-level sections of the ``cumulusci.yml`` file: ``project``, ``tasks``, ``flows``, ``sources``, ``orgs``, and ``plans``.

* ``project`` - This section is largely generated by running ``cci project init`` and contains information pertaining to the project's package information (if any) and GitHub information.

* ``tasks`` - This section defines the tasks that are available to run in your project. See `task configurations`_ for more info on the types of configurations that can be made in this section.

* ``flows`` - This section defines the flows that are available to run in your project. See `flow configurations`_ for more info on the types of configurations that can be made in this section.

* ``sources`` - This section makes it possible to reference tasks and flows from another CumulusCI project on GitHub. See the `using tasks and flows from a different project`_ section for more info.

* ``orgs`` - This section defines the scratch org configurations that are available for your project. See `org configurations`_ for more info on the types of configurations that can be made in this section.

* ``plans`` - This section contains any custom plans you have defined for how to install your project into a customer org. For more information see `configuring plans in MetaDeploy<TODO>`_.

For a complete list of values that can be used in each section see: `cumulusci.yml reference`_.


Task Configurations
-------------------
Task configurations are made under the ``tasks`` section of your project's ``cumulusci.yml`` file.
Each task configuration defines a task which can be run using the ``cci task run`` command, or included in a flow step.
With some simple changes to this section, you can configure a lot of build automation functionality without ever touching any Python code.



Overriding a Task Option
^^^^^^^^^^^^^^^^^^^^^^^^
If you are continually specifying the same value for an option while running a task, you can configure CumulusCI to use that particular value when running a task without needing to specify it yourself.
Say that you want to enforce a 90% code coverage requirement for Apex code in your project. 
The `run_tests <TODO>`_ task, which executes all Apex Tests in a target org, can be passed the `required_org_code_coverage_percent` option to enfore code coverage at a given percentage.

.. code-block:: yaml

    run_tests:
        options:
            required_org_code_coverage_percent: 90

Placing this code under the ``tasks`` section of the project's ``cumulusci.yml`` file tells CumulusCI to override the given option with a value of ``90``.
The overridden option will be used wshenever this task is called as part of this project's automation, unless it is further overridden for a particular flow step.
With this change in place we can verify the change by looking for a default option value when examining the task information:

.. code-block:: yaml

    $ cci task info run_tests
    run_tests

    Description: Runs all apex tests

    Class: cumulusci.tasks.apex.testrunner.RunApexTests

    Command Syntax

        $ cci task run run_tests

    Options
        .
        .
        .
      -o required_org_code_coverage_percent PERCENTAGE
        Optional
        Require at least X percent code coverage across the org following the test run.
        Default: 90



Add a Custom Task
^^^^^^^^^^^^^^^^^
Say that you want to take the above example and create a custom task named ``deploy_reports`` to make it more apparent what this task is doing.
First, look up the Python class associated with the standard task ``deploy``. We can see above that the ``deploy`` task has a ``class_path`` value of ``cumulusci.tasks.salesforce.Deploy``.
Let's assume there are reports that are a part of your package's unpackaged Metadata that live at ``unpackaged/config/reports``.

Now you can add the following under the ``tasks:`` section of your ``cumulusci.yml`` file, include the value we retrieved for ``class_path``.

.. code-block:: yaml

    deploy_reports:
        description: Deploy Reports 
        class_path: cumulusci.tasks.salesforce.Deploy
        group: projectName
        options:
            path: unpackaged/config/reports

Congratulations! You have created a new custom task in CumulusCI!
Adding a common ``group`` attribute to your custom tasks makes it easy to see the tasks that are specific to your project with ``cci task list``.

For additional examples of custom tasks see our `task recipes`_ section in the cookbook.

If you want to `write a custom task in python <TODO>`_ and make it available to other users in the project you would need to update your ``cumulusci.yml`` file's ``task`` section with the following:

.. code-block:: yaml

    tasks:
        my_new_task:
            description: Description of the task
            class_path: tasks.task_file.MyTaskClass
            group: projectName

The above assumes that your task's class is named ``MyTaskClass`` and exists in the file ``tasks/task_file.py``.



Using Variables for Task Options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Sometimes you may want to reference a specific value within the ``cumulusci.yml`` file.
To do this we can use the ``$project_config`` variable.
You can use a double underscore ( ``__`` ) to access the different levels of the ``cumulusci.yml`` file.

For example, NPSP uses a variable to the project's namespace by setting a value of ``$project_config.project__package__namespace``.
Here is an example task that does just this to provide a value for the ``namespace_inject`` option in a custom deploy task:

.. code-block:: yaml

    deploy_qa_config:
            description: Deploys additional fields used for QA purposes only
            class_path: cumulusci.tasks.salesforce.Deploy
            group: Salesforce Metadata
            options:
                path: unpackaged/config/qa
                namespace_inject: $project_config.project__package__namespace

CumulusCI will replace the variable with the value currently located under project -> package -> namespace in the ``cumulusci.yml`` file.
Here is the ``project`` section of NPSP's ``cumulusci.yml`` file:

.. code-block:: yaml

    project:
        name: Cumulus
        package:
            name: Cumulus
            name_managed: Nonprofit Success Pack
            namespace: npsp
            api_version: 48.0
            install_class: STG_InstallScript
            uninstall_class: STG_UninstallScript

Currently under ``$project_config.project__package__namespace`` is the value: ``npsp``.



Referencing Task Return Values
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Tasks can set an internal `return_value` on themselves while executing.
This allows one task in a flow to reference the `return_value` set on another task that executed prior to it.

To reference a return value on a previous task use the following:

.. code-block:: yaml

    ^^prior_task.return_value


In order to know what is available for ``<return_value>`` we need to find the source code for an individual task.
Let's examine the definition for the ``upload_beta`` task. The universal ``cumulusci.yml`` file defines it as follows:

.. code-block:: yaml

    upload_beta:
            description: Uploads a beta release of the metadata currently in the packaging org
            class_path: cumulusci.tasks.salesforce.PackageUpload
            group: Release Operations

This informs us that we need to find where the class ``cumulusci.tasks.salesforce.PackageUpload`` is defined to see if anything is being set on ``self.return_values``.
Some digging yields that this class is defined in the file `package_upload.py <>`_ and has a method called ``_set_return_values()``.
`This method <https://github.com/SFDO-Tooling/CumulusCI/blob/3cad07ac1cecf438aaf087cdeff7b781a1fc74a1/cumulusci/tasks/salesforce/package_upload.py#L165>`_ sets ``self.return_values`` to a dictionary with the following keys: ``verison_number``, ``version_id``, and ``package_id``.

Let's now look at the the ``release_beta`` flow as its defined in the universal cumulusci.yml file:

.. code-block:: yaml

   release_beta:
        description: Upload and release a beta version of the metadata currently in packaging
        steps:
            1:
                task: upload_beta
                options:
                    name: Automated beta release
            2:
                task: github_release
                options:
                    version: ^^upload_beta.version_number
            3:
                task: github_release_notes
                ignore_failure: True  # Attempt to generate release notes but don't fail build
                options:
                    link_pr: True
                    publish: True
                    tag: ^^github_release.tag_name
                    include_empty: True
                    version_id: ^^upload_beta.version_id
            4:
                task: github_master_to_feature

This flow references both ``version_id`` and ``version_number`` return values set on the ``upload_beta`` task.



Flow Configurations
-------------------
Flow configurations are made under the ``flows`` section of your project's ``cumulusci.yml`` file.
Each flow configuration defines a flow which can be run using the ``cci flow run`` command, or included in a flow step.



Add a Custom Flow
^^^^^^^^^^^^^^^^^
To define a new flow for your project, simply add the name of the new flow under the ``flows`` section of your ``cumulusci.yml`` file.

.. code-block:: yaml

    greet_and_sleep:
        group: projectName
        description: Greets the user and then sleeps for 5 seconds.
        steps:
            1:
                task: command
                options:
                    command: echo 'Hello there!' 
            2:
                task: util_sleep

This is a flow comprised of two tasks; ``command`` greets the user by echoing and string, and ``util_sleep`` then tells CumulusCI to sleep for five seconds.
You can reference how the flows are defined in the universal ``cumulusci.yml`` file `here <https://github.com/SFDO-Tooling/CumulusCI/blob/d038f606d97f50a71ba1d2d6e9462a249b28864e/cumulusci/cumulusci.yml#L565>`_.


Add a Flow Step
^^^^^^^^^^^^^^^
If you want to add a step to a flow, you first need to know what the existing steps are.
The easiest way to see this is with ``cci flow info <flow_name>``.
Take the ``dev_org`` flow as an example:

.. code-block:: console

    $ cci flow info dev_org
    Description: Set up an org as a development environment for unmanaged metadata
    1) flow: dependencies [from current folder]
        1) task: update_dependencies
        2) task: deploy_pre
    2) flow: deploy_unmanaged
        0) task: dx_convert_from
        when: project_config.project__source_format == "sfdx" and not org_config.scratch
        1) task: unschedule_apex
        2) task: update_package_xml
        when: project_config.project__source_format != "sfdx" or not org_config.scratch
        3) task: deploy
        when: project_config.project__source_format != "sfdx" or not org_config.scratch
        3.1) task: dx_push
            when: project_config.project__source_format == "sfdx" and org_config.scratch
        4) task: uninstall_packaged_incremental
        when: project_config.project__source_format != "sfdx" or not org_config.scratch
    3) flow: config_dev
        1) task: deploy_post
        2) task: update_admin_profile
    4) task: snapshot_changes

There are four steps to this flow. The first three steps are themselves flows, and the last step is a task.

All **non-negative numbers and decimals** are valid as step numbers in a flow.
This makes it easy to add steps before, in-between, or after existing flow steps.
If we wanted to add a step at the beginning of the dev org flow, valid step numbers would include any number greater than or equal to zero and less than 1.
Example values would include: 0, 0.3, and 0.89334.
All of these would cause the step to execute before step 1 in the ``dev_org`` flow.

If you want to add a step **between** steps 2 and 3, then a step number of 2.5 can be used.

If you want to add a step **after** all steps in the flow, then any step number greater than 4 can be used.

You could add an additional log line at the end of the ``dev_org`` flow with the following under the ``flows`` section of your project's ``cumulusci.yml`` file:

.. code-block:: yaml

    dev_org:
        steps:
            5:
                task: log
                    options:
                        line: dev_org flow has completed




Skip a Flow Step
^^^^^^^^^^^^^^^^
To skip a flow step, set the desired step number to a task or flow with the value of ``None``.
The following would skip the 4th step from the ``dev_org`` flow.

.. code-block:: yaml

    dev_org:
        steps:
            4:
                task: None

.. note::
    The value of ``task`` must be used when skipping a flow step that is a task.
    The value of ``flow`` must be used when skipping a flow step that corresponds to a flow.

When CumulusCI detects a task with this value, it is skipped:

.. image:: images/skipping_task.png



Replace a Flow Step
^^^^^^^^^^^^^^^^^^^
To replace a flow step, simply name the task or flow you wish to run in place of the current step.

The following would replace the fourth step of the ``dev_org`` flow with a custom task that loads data into a dev environment.
Since this is replacing one task with another, we can simply specify the task we want to use for the fourth step:

.. code-block:: yaml

    dev_org:
        steps:
            4:
                task: load_data_dev


If we want to instead replace the existing task with a flow as the fourth step of the ``dev_org`` flow we need to set ``task: None``.

.. code-block:: yaml

    dev_org:
        steps:
            4:
                task: None
                flow: my_flow

You can swap two steps in a flow by replacing one with the other.
If the steps are of different types (task/flow) then the types being replaced will need to be set to ``None`` as mentioned above.



Configuring Options on Tasks When Running a Subflow
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
You can specify options on tasks in subflows with the following syntax:

.. code-block:: yaml

    <flow_to_modify>:
        steps:
            <step_number>:
                flow: <sub_flow_name>
                options:
                    <task_name>:
                        <option_name>: <value>

All values with ``<>`` would be replaced with the desired values.
Let's examine the definition of the ``ci_master`` flow from the universal ``cumulusci.yml`` file:

.. code-block::

    ci_master:
        group: Continuous Integration
        description: Deploy the package metadata to the packaging org and prepare for managed package version upload.  Intended for use against main branch commits.
        steps:
            1:
                flow: dependencies
                options:
                    update_dependencies:
                        include_beta: False
            2:
                flow: deploy_packaging
            3:
                flow: config_packaging

This flow specifies that when the sub-flow ``dependencies`` runs, to pass the ``include_beta`` option with a value of ``False`` to the ``update_dependencies`` task (executed in the ``dependencies`` sub-flow). 



Using ``when`` Clauses
^^^^^^^^^^^^^^^^^^^^^^
You can specify a ``when`` clause in a flow step to conditionally run that step.
A ``when`` clause is written in a Pythonic syntax that can evaluate to a boolean result.

The variables that are available for reference in when clasues 

A common use case is to be able to check 

See `using variables for task options`_ for more information.



Scratch Org Configurations
--------------------------
This section defines the scratch org configurations that are available without explicitly running ``cci org scratch`` to create a new configuration.
If you're looking for more information on using scratch orgs with CumulusCI, see `Scratch Org Environments`_. 



Override Default Values
^^^^^^^^^^^^^^^^^^^^^^^
These overrides pertain only to scratch orgs.
You can override the following values for org:

* ``days`` - integer - Number of days for the scratch org to persist.
* ``namespaced`` - boolean - Whether or not the scratch org is a `namespaced org <TODO sf link?>`_.
* ``config_file`` - string - Path to the org definition file to use when building the scratch org.

To override a value you can use the following syntax

.. code-block:: yaml
    
    orgs:
        scratch:
            org_name:
                key: value 

The following demonstrates how to override the default number of days from 7 to 15 on the ``dev`` org:

.. code-block:: yaml

    orgs:
        dev:
            days: 15


Configuration Scopes
--------------------
When we reference ``cumulusci.yml`` in our documentation, we are referring to the ``cumulusci.yml`` file located in your project's root directory.
In actuality, CumulusCI merges multiple `YAML <https://yaml.org/>`_ files that allow for configuration to occur at several distinct scopes.
All of these files have the same name, ``cumulusci.yml``, but live in different locations on the file system.

You can configure files at three scope levels: Project, Local Project, Global.
Configurations have the following order of override precedence (from highest to lowest):

* Project
* Local Project
* Global

One override will only cascade over another when two configurations are setting a value for the same element on a task or flow.
For example, say there exists a task T that takes two options o1 and o2.
You can specify a default value for o1 in your project's ``cumulusci.yml`` file and a default for o2 in your global ``cumulusci.yml`` file and you'll see the expected result - both values are available in the project, but the default of o1 is not exposed to other projects.
If you then change your project's ``cumulusci.yml`` file to also specify a default value for o2, this will take precedence over the default value specified in your global ``cumulusci.yml`` file.

The following diagram illustrates these three files along with their corresponding scopes in green.
Changes made to configuration files on top will override any changes in files below them (if they are present).



Project Configurations
^^^^^^^^^^^^^^^^^^^^^^
**macOS/Linux:** ``.../path/to/project/cumulusci.yml``

**Windows:** ``...\path\to\project\cumulusci.yml``

This ``cumulusci.yml`` file lives in the root directory of your project, and applies to only this project.
Changes here can be commited back to a remote repository so other team members can benefit from the customizations.
Configurations in this file apply to this project, and take precedence over any configurations specified in the `global configurations`_ file, but are overridden by configurations in the `local project`_ file.



Local Project Configurations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
**macOS/Linux:** ``~/.cumulusci/project_name/cumulusci.yml``

**Windows:** ``%homepath%\.cumulusci\project_name\cumulusci.yml``

Configurations made to this ``cumulusci.yml`` file apply to only the project with the given <project_name>, and take precedence over **all other** configuration scopes except the universal ``cumulusci.yml`` file.
If you want to make customizations to a project, but don't need them to be available to other team members, you would make those customizations here.



Global Configurations
^^^^^^^^^^^^^^^^^^^^^
**macOS/Linux:** ``~/.cumulusci/cumulusci.yml``

**Windows:** ``%homepath%\.cumulusci\cumulusci.yml``

Configuration of this file will override behavior across **all** CumulusCI projects on your machine.
Configurations in this file have a low precedence, and are overridden by **all other** configurations except for those that are in the universal ``cumulusci.yml`` file.



Universal Configurations
^^^^^^^^^^^^^^^^^^^^^^^^
There is one more configuration file that exists: the `universal cumulusci.yml <https://github.com/SFDO-Tooling/CumulusCI/blob/master/cumulusci/cumulusci.yml>`_ file that ships with CumulusCI itself.
This file actually holds the lowest precedence of all, as all other scopes override what is contained in this file.
This file contains all of the definitions for the standard tasks, flows, and org configurations that come out of the box with CumulusCI.

The commands ``cci task info`` and ``cci flow info`` display all of the infomation regarding how a particular task or flow is configured.
They display both the information present in the standard library alongside any customizations that have been added.



Advanced Configurations
-----------------------



Using Tasks and Flows From a Different Project
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
With CumulusCI, it's also possible to use arbitrary tasks and flows from another project.
To do this, the other project must be named in the ``sources`` section of the ``cumulusci.yml``:

.. code-block:: yaml

    sources:
      npsp:
        github: https://github.com/SalesforceFoundation/NPSP

This says that when tasks or flows are referenced using the `npsp` namespace, CumulusCI should fetch the source from this GitHub repository.
By default, it will fetch the most recent release, or the default branch if there are no releases.

.. note::
    In order for this feature to work, the referenced repository needs to be readable (i.e. either it's public, or CumulusCI's GitHub service is configured with the token of a user who has read access to it).

It's also possible to fetch a specific ``tag``:

.. code-block:: yaml

    sources:
      npsp:
        github: https://github.com/SalesforceFoundation/NPSP
        tag: rel/3.163

or a specific ``commit`` or ``branch``.

Now it's possible to run a flow from NPSP:

.. code-block:: console

    $ cci flow run npsp:install_prod

Or a task:

.. code-block:: console

    $ cci task run npsp:robot

Or even to create a new flow which uses a flow from NPSP:

.. code-block:: yaml

    flows:
      install_npsp:
        steps:
          1:
            flow: npsp:install_prod
          2:
            flow: dev_org

This flow will use NPSP's ``install_prod`` flow to install NPSP as a managed package, and then run this project's own ``dev_org`` flow.



Troubleshooting Configurations
------------------------------
Use ``cci task info <task_name>`` and ``cci flow info <flow_name>`` to see how a given task or flow will behave with the current state of configuration.
For example, the ``util_sleep`` task has a ``seconds`` option that defaults to 5 out-of-the-box:

.. code-block:: console

    $ cci task info util_sleep
    util_sleep

    Description: Sleeps for N seconds

    Class: cumulusci.tasks.util.Sleep

    Command Syntax

        $ cci task run util_sleep

    Options

        -o seconds SECONDS
        Required
        The number of seconds to sleep
        Default: 5

If you instead want the default value to be 30 seconds for all projects you could add the following in your global ``cumulusci.yml`` file locaated at ``~/.cumulusci/cumulusci.yml``:

.. code-block:: yaml

    tasks:
        util_sleep:
            options:
                seconds: 30

And now ``cci task info util_sleep`` shows a default of 30 seconds:

.. code-block:: console

    $ cci task info util_sleep
    util_sleep

    Description: Sleeps for N seconds

    Class: cumulusci.tasks.util.Sleep

    Command Syntax

        $ cci task run util_sleep

    Options

        -o seconds SECONDS
        Required
        The number of seconds to sleep
        Default: 30

Being able to display the active configuration for a given task or flow can help with cross-correlating which configuration scope is affecting a specific scenario.

