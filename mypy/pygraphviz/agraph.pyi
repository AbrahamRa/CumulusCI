# Stubs for pygraphviz.agraph (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import threading
from collections import MutableMapping
from typing import Any, Optional, Iterator

def is_string_like(obj: Any):
    pass

class PipeReader(threading.Thread):
    result: Any = ...
    pipe: Any = ...
    def __init__(self, result: Any, pipe: Any) -> None: ...
    def run(self) -> None: ...

class _Action:
    find: Any = ...
    create: Any = ...

class DotError(ValueError): ...

class AGraph:
    handle: Any = ...
    has_layout: bool = ...
    encoding: Any = ...
    graph_attr: Any = ...
    node_attr: Any = ...
    edge_attr: Any = ...
    def __init__(
        self,
        thing: Optional[Any] = ...,
        filename: Optional[Any] = ...,
        data: Optional[Any] = ...,
        string: Optional[Any] = ...,
        handle: Optional[Any] = ...,
        name: str = ...,
        strict: bool = ...,
        directed: bool = ...,
        **attr: Any
    ) -> None: ...
    def __enter__(self): ...
    def __exit__(self, ext_type: Any, exc_value: Any, traceback: Any) -> None: ...
    def __unicode__(self): ...
    def __eq__(self, other: Any): ...
    def __hash__(self): ...
    def __iter__(self): ...
    def __contains__(self, n: Any): ...
    def __len__(self): ...
    def __getitem__(self, n: Any): ...
    def get_name(self): ...
    name: Any = ...
    def add_node(self, n: Any, **attr: Any) -> None: ...
    def add_nodes_from(self, nbunch: Any, **attr: Any) -> None: ...
    def remove_node(self, n: Any) -> None: ...
    delete_node: Any = ...
    def remove_nodes_from(self, nbunch: Any) -> None: ...
    delete_nodes_from: Any = ...
    def nodes_iter(self) -> None: ...
    iternodes: Any = ...
    def nodes(self): ...
    def number_of_nodes(self): ...
    def order(self): ...
    def has_node(self, n: Any): ...
    def get_node(self, n: Any): ...
    def add_edge(
        self, u: Any, v: Optional[Any] = ..., key: Optional[Any] = ..., **attr: Any
    ) -> None: ...
    def add_edges_from(self, ebunch: Any, **attr: Any) -> None: ...
    def get_edge(self, u: Any, v: Any, key: Optional[Any] = ...): ...
    def remove_edge(
        self, u: Any, v: Optional[Any] = ..., key: Optional[Any] = ...
    ) -> None: ...
    delete_edge: Any = ...
    def remove_edges_from(self, ebunch: Any) -> None: ...
    delete_edges_from: Any = ...
    def has_edge(self, u: Any, v: Optional[Any] = ..., key: Optional[Any] = ...): ...
    def edges(self, nbunch: Optional[Any] = ..., keys: bool = ...): ...
    def has_neighbor(self, u: Any, v: Any, key: Optional[Any] = ...): ...
    def neighbors_iter(self, n: Any) -> None: ...
    def neighbors(self, n: Any): ...
    iterneighbors: Any = ...
    def out_edges_iter(self, nbunch: Optional[Any] = ..., keys: bool = ...) -> None: ...
    iteroutedges: Any = ...
    def in_edges_iter(self, nbunch: Optional[Any] = ..., keys: bool = ...) -> None: ...
    def edges_iter(self, nbunch: Optional[Any] = ..., keys: bool = ...) -> None: ...
    iterinedges: Any = ...
    iteredges: Any = ...
    def out_edges(self, nbunch: Optional[Any] = ..., keys: bool = ...): ...
    def in_edges(self, nbunch: Optional[Any] = ..., keys: bool = ...): ...
    def predecessors_iter(self, n: Any) -> None: ...
    iterpred: Any = ...
    def successors_iter(self, n: Any) -> None: ...
    itersucc: Any = ...
    def successors(self, n: Any): ...
    def predecessors(self, n: Any): ...
    out_neighbors: Any = ...
    in_neighbors: Any = ...
    def degree_iter(
        self, nbunch: Optional[Any] = ..., indeg: bool = ..., outdeg: bool = ...
    ) -> None: ...
    def in_degree_iter(self, nbunch: Optional[Any] = ...): ...
    def out_degree_iter(self, nbunch: Optional[Any] = ...): ...
    iteroutdegree: Any = ...
    iterindegree: Any = ...
    def out_degree(self, nbunch: Optional[Any] = ..., with_labels: bool = ...): ...
    def in_degree(self, nbunch: Optional[Any] = ..., with_labels: bool = ...): ...
    def reverse(self): ...
    def degree(self, nbunch: Optional[Any] = ..., with_labels: bool = ...): ...
    iterdegree: Any = ...
    def number_of_edges(self): ...
    def clear(self) -> None: ...
    def close(self) -> None: ...
    def copy(self): ...
    def add_path(self, nlist: Any) -> None: ...
    def add_cycle(self, nlist: Any) -> None: ...
    def prepare_nbunch(self, nbunch: Optional[Any] = ...): ...
    def add_subgraph(
        self, nbunch: Optional[Any] = ..., name: Optional[Any] = ..., **attr: Any
    ): ...
    def remove_subgraph(self, name: Any) -> None: ...
    delete_subgraph: Any = ...
    subgraph: Any = ...
    def subgraph_parent(
        self, nbunch: Optional[Any] = ..., name: Optional[Any] = ...
    ): ...
    def subgraph_root(self, nbunch: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def get_subgraph(self, name: Any): ...
    def subgraphs_iter(self) -> None: ...
    def subgraphs(self): ...
    def is_strict(self): ...
    strict: Any = ...
    def is_directed(self): ...
    directed: Any = ...
    def is_undirected(self): ...
    def to_undirected(self): ...
    def to_directed(self, **kwds: Any): ...
    def read(self, path: Any) -> None: ...
    def write(self, path: Optional[Any] = ...) -> None: ...
    def string_nop(self): ...
    def to_string(self): ...
    def string(self): ...
    def from_string(self, string: Any): ...
    def unflatten(self, args: str = ...): ...
    def layout(self, prog: str = ..., args: str = ...) -> None: ...
    def tred(self, args: str = ..., copy: bool = ...): ...
    def acyclic(self, args: str = ..., copy: bool = ...): ...
    def draw(
        self,
        path: Optional[Any] = ...,
        format: Optional[Any] = ...,
        prog: Optional[Any] = ...,
        args: str = ...,
    ): ...

class Node:
    def __new__(
        self, graph: Any, name: Optional[Any] = ..., nh: Optional[Any] = ...
    ): ...
    def get_handle(self): ...
    def get_name(self): ...
    name: Any = ...

class Edge(tuple):
    def __new__(
        self,
        graph: Any,
        source: Optional[Any] = ...,
        target: Optional[Any] = ...,
        key: Optional[Any] = ...,
        eh: Optional[Any] = ...,
    ): ...
    def get_name(self): ...
    name: Any = ...
    key: Any = ...

class Attribute(MutableMapping):
    handle: Any = ...
    type: Any = ...
    encoding: Any = ...
    def __init__(self, handle: Any, atype: Any) -> None: ...
    def __setitem__(self, name: Any, value: Any) -> None: ...
    def __getitem__(self, name: Any): ...
    def __delitem__(self, name: Any) -> None: ...
    def __contains__(self, name: Any): ...
    def __len__(self): ...
    def has_key(self, name: Any): ...
    def keys(self): ...
    def __iter__(self) -> Iterator[Any]: ...
    def iteritems(self) -> None: ...

class ItemAttribute(Attribute):
    handle: Any = ...
    type: Any = ...
    ghandle: Any = ...
    encoding: Any = ...
    def __init__(self, handle: Any, atype: Any) -> None: ...
    def __setitem__(self, name: Any, value: Any) -> None: ...
    def __getitem__(self, name: Any): ...
    def __delitem__(self, name: Any) -> None: ...
    def iteritems(self) -> None: ...
